// inout creates compressed backup files and can restore a flaarum project from the said files.
package main

import (
	"fmt"
	"os"
	"io"
	"time"
	"path/filepath"
	"compress/gzip"
	"github.com/otiai10/copy"
	"github.com/bankole7782/mof"
	"github.com/bankole7782/flaarum/flaarum_shared"
	"github.com/gookit/color"
	"encoding/json"
	"sync"
	"strings"
	"strconv"
	"github.com/pkg/errors"
	"io/fs"
)


func main() {
	if len(os.Args) < 2 {
		color.Red.Println("Wrong number of inputs. Run this program with --help to view the help message.")
		os.Exit(1)
	}

	switch os.Args[1] {
	case "help", "h", "--help":
		fmt.Println(`flaarum's inout program backs up and restores a flaarum project. It doesn't add the indexes to a backup
thereby compressing it. This is because the index can be created from the data.

Available Commands:

  out     Out command creates a backup of a flaarum project. It expects the flaarum project as its only argument.

  in      In command restores a backup of a flaarum project. It expects the name of the flaarum project to be
          restored into and a file containing the backup data. This file must reside in the directory gotten from
          "flaarum.cli pwd"

			`)
	case "out":
		if len(os.Args) < 3 {
			color.Red.Println("Expecting the name of the project as the last argument.")
			os.Exit(1)
		}
		projName := os.Args[2]

		dataPath, err := flaarum_shared.GetDataPath()
		if err != nil {
			panic(err)
		}

		tmpFolderName := fmt.Sprintf(".flaarumout-%s", flaarum_shared.UntestedRandomString(10))
		tmpFolder, err := flaarum_shared.GetFlaarumPath(tmpFolderName)
		if err != nil {
			panic(err)
		}

		err = os.MkdirAll(tmpFolder, 0777)
		if err != nil {
			panic(err)
		}
		defer os.RemoveAll(tmpFolder)

		projPath := filepath.Join(dataPath, projName)

		tblFIs, err := os.ReadDir(projPath)
		for _, tblFI := range tblFIs {

			if projName == "first_proj" && tblFI.Name() == "server_stats" {
				continue
			}

			err := copy.Copy(filepath.Join(projPath, tblFI.Name(), "structures"), filepath.Join(tmpFolder, "out", tblFI.Name(), "structures"))
			if err != nil {
				panic(err)
			}

			err = copy.Copy(filepath.Join(projPath, tblFI.Name(), "data"), filepath.Join(tmpFolder, "out", tblFI.Name(), "data"))
			if err != nil {
				panic(err)
			}

			_ = copy.Copy(filepath.Join(projPath, tblFI.Name(), "lastId"), filepath.Join(tmpFolder, "out", tblFI.Name(), "lastId"))
		}

		err = mof.MOF(filepath.Join(tmpFolder, "out"), filepath.Join(tmpFolder, "out.mof"))
		if err != nil {
			panic(err)
		}

		outFileName := fmt.Sprintf("flaarumout-%s.%s", time.Now().Format("20060102T1504"), flaarum_shared.BACKUP_EXT)

		outFilePath, err := flaarum_shared.GetFlaarumPath(outFileName)
		if err != nil {
			panic(err)
		}

		outFile, err := os.Create(outFilePath)
		if err != nil {
			panic(err)
		}
		defer outFile.Close()
		zw := gzip.NewWriter(outFile)
		zw.Name = outFileName
		zw.Comment = "backup output from flaarum"
		zw.ModTime = time.Now()

		mofBytes, err := os.ReadFile(filepath.Join(tmpFolder, "out.mof"))
		if err != nil {
			panic(err)
		}
		_, err = zw.Write(mofBytes)
		if err != nil {
			panic(err)
		}

		if err := zw.Close(); err != nil {
			panic(err)
		}

		fmt.Printf(outFilePath)

	case "in":
		if len(os.Args) < 4 {
			color.Red.Println("Expecting the project name and the input file name.")
			os.Exit(1)
		}
		projName := os.Args[2]
		inputPath, err := flaarum_shared.GetFlaarumPath(os.Args[3])
		if err != nil {
			panic(err)
		}

		if filepath.Ext(os.Args[3]) != "." + flaarum_shared.BACKUP_EXT {
			color.Red.Printf("This file '%s' was not generated by flaarum inout.\n", os.Args[3])
			os.Exit(1)
		}

		if ! flaarum_shared.DoesPathExists(inputPath) {
			color.Red.Printf("The file '%s' does not exists in the flaarum working directory.\n", os.Args[3])
			os.Exit(1)
		}

		dataPath, err := flaarum_shared.GetDataPath()
		if err != nil {
			panic(err)
		}

		tmpFolderName := fmt.Sprintf(".flaarumin-%s", flaarum_shared.UntestedRandomString(10))
		tmpFolder, err := flaarum_shared.GetFlaarumPath(tmpFolderName)
		if err != nil {
			panic(err)
		}

		err = os.MkdirAll(tmpFolder, 0777)
		if err != nil {
			panic(err)
		}
		defer os.RemoveAll(tmpFolder)

		inputFile, err := os.Open(inputPath)
		if err != nil {
			panic(err)
		}
		defer inputFile.Close()

		zr, err := gzip.NewReader(inputFile)
		if err != nil {
			panic(err)
		}

		mofBytes, err := io.ReadAll(zr)
		if err != nil {
			panic(err)
		}

		err = os.WriteFile(filepath.Join(tmpFolder, "out.mof"), mofBytes, 0777)
		if err != nil {
			panic(err)
		}

		err = mof.UndoMOF(filepath.Join(tmpFolder, "out.mof"), tmpFolder)
		if err != nil {
			panic(err)
		}

		tblFIs, err := os.ReadDir(filepath.Join(tmpFolder, "out"))
		if err != nil {
			panic(err)
		}

		var wg sync.WaitGroup
		for _, tblFI := range tblFIs {
			wg.Add(1)

			go func(tblFI fs.DirEntry, wg *sync.WaitGroup) {
				defer wg.Done()

				err = copy.Copy(filepath.Join(tmpFolder, "out", tblFI.Name(), "structures"), filepath.Join(dataPath, projName, tblFI.Name(), "structures"))
		    if err != nil {
		    	panic(err)
		    }
		    err = copy.Copy(filepath.Join(tmpFolder, "out", tblFI.Name(), "data"), filepath.Join(dataPath, projName, tblFI.Name(), "data"))
		    if err != nil {
		    	os.MkdirAll(filepath.Join(dataPath, projName, tblFI.Name(), "data"), 0777)
		    }
		    _ = copy.Copy(filepath.Join(tmpFolder, "out", tblFI.Name(), "lastId"), filepath.Join(dataPath, projName, tblFI.Name(), "lastId"))

		    toMakePath := filepath.Join(dataPath, projName, tblFI.Name(), "indexes")
		    err = os.MkdirAll(toMakePath, 0777)
		    if err != nil {
		    	panic(err)
		    }

				toMakePath = filepath.Join(dataPath, projName, tblFI.Name(), "txtinstrs")
				err = os.MkdirAll(toMakePath, 0777)
				if err != nil {
					panic(err)
				}

				toMakePath = filepath.Join(dataPath, projName, tblFI.Name(), "intindexes")
				err = os.MkdirAll(toMakePath, 0777)
				if err != nil {
					panic(err)
				}

				toMakePath = filepath.Join(dataPath, projName, tblFI.Name(), "timeindexes")
				err = os.MkdirAll(toMakePath, 0777)
				if err != nil {
					panic(err)
				}

		    rowFIs, err := os.ReadDir(filepath.Join(dataPath, projName, tblFI.Name(), "data"))
		    if err != nil {
		    	panic(err)
		    }

		    ts, err := flaarum_shared.GetTableStructureParsed(projName, tblFI.Name(), 1)
		    if err != nil {
		    	panic(err)
		    }

		    for _, rowFI := range rowFIs {
					rowMap := make(map[string]string)
					rowBytes, err := os.ReadFile(filepath.Join(dataPath, projName, tblFI.Name(), "data", rowFI.Name()))
					if err != nil {
						panic(err)
					}
					err = json.Unmarshal(rowBytes, &rowMap)
					if err != nil {
						panic(err)
					}

					if ts.TableType == "proper" {
						// create indexes
					  for k, v := range rowMap {
					  	if k == "id" {
					  		continue
					  	}

					    if isFieldExemptedFromIndexingVersioned(projName, tblFI.Name(), k, rowMap["_version"]) {

					    	// create a .text file which is a message to the tindexer program.
				        newTextFileName := rowFI.Name() + flaarum_shared.TEXT_INTR_DELIM + k + ".text"
				        err = os.WriteFile(filepath.Join(dataPath, projName, tblFI.Name(), "txtinstrs", newTextFileName), []byte(v), 0777)
				        if err != nil {
				          fmt.Printf("%+v\n", errors.Wrap(err, "ioutil error."))
				        }
							} else if flaarum_shared.IsNotIndexedFieldVersioned(projName, tblFI.Name(), k, rowMap["_version"]) {
								// don't create indexes
					    } else {

						    err := flaarum_shared.MakeIndex(projName, tblFI.Name(), k, v, rowFI.Name())
						    if err != nil {
						      panic(err)
						    }

					    }

					  }
					} else {

						for k, v := range rowMap {
				      if k == "created" || strings.HasPrefix(k, "created_") || k == "_version" {
				        err = flaarum_shared.MakeIndex(projName, tblFI.Name(), k, v, rowFI.Name())
				        if err != nil {
				          fmt.Printf("%+v\n", err)
				        }
				      }
						}

					}

		    }

			}(tblFI, &wg)


		}

		wg.Wait()

	default:
		color.Red.Println("Unexpected command. Run this program 'inout' with --help to find out the supported commands.")
		os.Exit(1)
	}

}


func isFieldExemptedFromIndexingVersioned(projName, tableName, fieldName, version string) bool {
	versionNum, _ := strconv.Atoi(version)

  td, _ := flaarum_shared.GetTableStructureParsed(projName, tableName, versionNum)
  for _, fd := range td.Fields {
    if fd.FieldName == fieldName && fd.FieldType == "text" {
      return true
    }
  }
  return false

}
