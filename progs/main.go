package main

import (
  "github.com/gookit/color"
  "os"
  "fmt"
  "path/filepath"
  "github.com/saenuma/flaarum/flaarum_shared"
)


func main() {
  dataPath, err := flaarum_shared.GetDataPath()
  if err != nil {
    panic(err)
  }

	if len(os.Args) < 2 {
		color.Red.Println("Wrong number of inputs. Run this program with --help to view the help message.")
		os.Exit(1)
	}

	switch os.Args[1] {
	case "help", "h", "--help":
		fmt.Printf(`flaarum's progs launches long running programs needed in flaarum.

Available Commands:

  in      In command restores a backup of a flaarum project. It expects the name of the flaarum project to be
          restored into and a file containing the backup data. This file must reside in this part '%s'.
          This program must be ran with 'sudo'.

  ipa     Is programs active: This checks if a long running task is running.
          This program must be ran with 'sudo'.

  out     Out command creates a backup of a flaarum project. It expects the flaarum project as its only argument.
          This program must be ran with 'sudo'.


`, dataPath)

	case "out":
    if len(os.Args) < 3 {
      color.Red.Println("Expecting the name of the project as the last argument.")
      os.Exit(1)
    }

    outCommandInstr := filepath.Join(dataPath, "out.out_instr")
    hasLongRunningTaskActive := isLongRunningTaskActive()
    if hasLongRunningTaskActive {
      color.Red.Println("Wait for long running task(s) to be completed.")
      os.Exit(1)
    }

    err := os.WriteFile(outCommandInstr, []byte(os.Args[2]), 0777)
    if err != nil {
      panic(err)
    }

    fmt.Println("The export would be located at ", dataPath)
    fmt.Println("Wait for operation to finish before using the database.")


	case "in":
    hasLongRunningTaskActive := isLongRunningTaskActive()
    if hasLongRunningTaskActive {
      color.Red.Println("Wait for long running task(s) to be completed.")
      os.Exit(1)
    }

    if len(os.Args) < 4 {
      color.Red.Println("Expecting the project name and the input file name.")
      os.Exit(1)
    }
    projName := os.Args[2]
    inputPath := filepath.Join(dataPath, os.Args[3])

    if filepath.Ext(os.Args[3]) != "." + flaarum_shared.BACKUP_EXT {
      color.Red.Printf("This file '%s' was not generated by flaarum inout.\n", os.Args[3])
      os.Exit(1)
    }

    if ! flaarum_shared.DoesPathExists(inputPath) {
      color.Red.Printf("The file '%s' does not exists in the flaarum working directory.\n", os.Args[3])
      os.Exit(1)
    }

    inCommandInstrPath := filepath.Join(dataPath, "in.in_instr")
    out := projName + "\n" + inputPath
    err = os.WriteFile(inCommandInstrPath, []byte(out), 0777)
    if err != nil {
      panic(err)
    }
    fmt.Println("Wait for operation to finish before using the database.")

  case "ipa":
    status := isLongRunningTaskActive()
    if status {
      color.Red.Println("A long running task is running.")
    } else {
      color.Red.Println("No long running task is running.")
    }

	default:
		color.Red.Println("Unexpected command. Run this program 'inout' with --help to find out the supported commands.")
		os.Exit(1)
	}

}


func isLongRunningTaskActive() bool {
  dataPath, _ := flaarum_shared.GetDataPath()
  outCommandInstrPath := filepath.Join(dataPath, "out.out_instr")
  inCommandInstrPath := filepath.Join(dataPath, "in.in_instr")

  if flaarum_shared.DoesPathExists(outCommandInstrPath) {
    return true
  } else if flaarum_shared.DoesPathExists(inCommandInstrPath) {
    return true
  }

  return false
}
